diff -ruN ygot-dir-orig/ygot/generator/generator.go ygot-dir/ygot/generator/generator.go
--- ygot-dir-orig/ygot/generator/generator.go	2020-10-07 14:33:58.430343000 -0700
+++ ygot-dir/ygot/generator/generator.go	2020-10-27 16:02:47.667985000 -0700
@@ -109,7 +109,7 @@
 }
 
 // writeIfNotEmpty writes the string s to b if it has a non-zero length.
-func writeIfNotEmpty(b io.StringWriter, s string) {
+func writeIfNotEmpty(b *strings.Builder, s string) {
 	if len(s) != 0 {
 		b.WriteString(s)
 	}
diff -ruN ygot-dir-orig/ygot/genutil/common.go ygot-dir/ygot/genutil/common.go
--- ygot-dir-orig/ygot/genutil/common.go	2020-10-07 14:33:58.413742000 -0700
+++ ygot-dir/ygot/genutil/common.go	2020-10-27 16:02:47.683147000 -0700
@@ -18,9 +18,9 @@
 
 import (
 	"fmt"
-	"io"
 	"sort"
-
+	"strings"
+	
 	"github.com/openconfig/goyang/pkg/yang"
 	"github.com/openconfig/ygot/util"
 	"github.com/openconfig/ygot/ygot"
@@ -42,7 +42,7 @@
 )
 
 // WriteIfNotEmpty writes the string s to b if it has a non-zero length.
-func WriteIfNotEmpty(b io.StringWriter, s string) {
+func WriteIfNotEmpty(b *strings.Builder, s string) {
 	if len(s) != 0 {
 		b.WriteString(s)
 	}
diff -ruN ygot-dir-orig/ygot/util/debug.go ygot-dir/ygot/util/debug.go
--- ygot-dir-orig/ygot/util/debug.go	2020-10-07 14:33:58.180210000 -0700
+++ ygot-dir/ygot/util/debug.go	2020-10-27 16:02:47.497624000 -0700
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package util
 
 import (
@@ -53,6 +56,14 @@
 	fmt.Println(globalIndent + out)
 }
 
+func IsDebugLibraryEnabled () bool {
+	return debugLibrary
+}
+
+func IsDebugSchemaEnabled () bool {
+	return debugSchema
+}
+
 // DbgSchema prints v if the package global variable debugSchema is set.
 // v has the same format as Printf.
 func DbgSchema(v ...interface{}) {
@@ -177,6 +188,9 @@
 
 // YangTypeToDebugString returns a debug string representation of a YangType.
 func YangTypeToDebugString(yt *yang.YangType) string {
+	if !debugLibrary {
+		return ""
+	}
 	out := fmt.Sprintf("(TypeKind: %s", yang.TypeKindToName[yt.Kind])
 	if len(yt.Pattern) != 0 {
 		out += fmt.Sprintf(", Pattern: %s", strings.Join(yt.Pattern, " or "))
diff -ruN ygot-dir-orig/ygot/util/path.go ygot-dir/ygot/util/path.go
--- ygot-dir-orig/ygot/util/path.go	2020-10-07 14:33:58.191131000 -0700
+++ ygot-dir/ygot/util/path.go	2020-10-27 16:02:47.508799000 -0700
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package util
 
 import (
@@ -19,10 +22,13 @@
 	"fmt"
 	"reflect"
 	"strings"
-
+	"sync"
 	"github.com/openconfig/goyang/pkg/yang"
 )
 
+var pathToSchemaCache map[reflect.StructTag][]string = make(map[reflect.StructTag][]string)
+var pathToSchemaMutex sync.RWMutex
+
 // SchemaPaths returns all the paths in the path tag.
 func SchemaPaths(f reflect.StructField) ([][]string, error) {
 	var out [][]string
@@ -49,25 +55,39 @@
 // leafref; the schema *yang.Entry for the field is given by
 // schema.Dir["config"].Dir["a"].
 func RelativeSchemaPath(f reflect.StructField) ([]string, error) {
-	pathTag, ok := f.Tag.Lookup("path")
-	if !ok || pathTag == "" {
-		return nil, fmt.Errorf("field %s did not specify a path", f.Name)
-	}
+	pathToSchemaMutex.RLock()
+	if pe, ok := pathToSchemaCache[f.Tag]; ok {
+		pathToSchemaMutex.RUnlock()
+		return pe, nil
+	} else {
+		pathToSchemaMutex.RUnlock()
+		pathTag, ok := f.Tag.Lookup("path")
+		if !ok || pathTag == "" {
+			return nil, fmt.Errorf("field %s did not specify a path", f.Name)
+		}
 
-	paths := strings.Split(pathTag, "|")
-	if len(paths) == 1 {
-		pathTag = strings.TrimPrefix(pathTag, "/")
-		return strings.Split(pathTag, "/"), nil
-	}
-	for _, pv := range paths {
-		pv = strings.TrimPrefix(pv, "/")
-		pe := strings.Split(pv, "/")
-		if len(pe) > 1 {
-			return pe, nil
+		paths := strings.Split(pathTag, "|")
+		if len(paths) == 1 {
+			pathTag = strings.TrimPrefix(pathTag, "/")
+			retPath := strings.Split(pathTag, "/")
+			pathToSchemaMutex.Lock()
+			pathToSchemaCache[f.Tag] = retPath
+			pathToSchemaMutex.Unlock()
+			return retPath, nil
+		}
+		for _, pv := range paths {
+			pv = strings.TrimPrefix(pv, "/")
+			pe := strings.Split(pv, "/")
+			if len(pe) > 1 {
+				pathToSchemaMutex.Lock()
+				pathToSchemaCache[f.Tag] = pe
+				pathToSchemaMutex.Unlock()
+				return pe, nil
+			}
 		}
-	}
 
-	return nil, fmt.Errorf("field %s had path tag %s with |, but no elements of form a/b", f.Name, pathTag)
+		return nil, fmt.Errorf("field %s had path tag %s with |, but no elements of form a/b", f.Name, pathTag)
+	}
 }
 
 // SchemaTreePath returns the schema tree path of the supplied yang.Entry
@@ -215,6 +235,10 @@
 		refSchema = refSchema.Dir[pe]
 	}
 
+	if refSchema.Type.Kind == yang.Yleafref {
+		return FindLeafRefSchema(refSchema, refSchema.Type.Path)
+	}
+
 	return refSchema, nil
 }
 
diff -ruN ygot-dir-orig/ygot/util/reflect.go ygot-dir/ygot/util/reflect.go
--- ygot-dir-orig/ygot/util/reflect.go	2020-10-07 14:33:58.196912000 -0700
+++ ygot-dir/ygot/util/reflect.go	2020-10-27 16:02:47.512819000 -0700
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package util
 
 import (
@@ -191,8 +194,10 @@
 
 // InsertIntoMap inserts value with key into parent which must be a map.
 func InsertIntoMap(parentMap interface{}, key interface{}, value interface{}) error {
-	DbgPrint("InsertIntoMap into parent type %T with key %v(%T) value \n%s\n (%T)",
-		parentMap, ValueStrDebug(key), key, pretty.Sprint(value), value)
+    if debugLibrary {
+	   DbgPrint("InsertIntoMap into parent type %T with key %v(%T) value \n%s\n (%T)",
+	      parentMap, ValueStrDebug(key), key, pretty.Sprint(value), value)
+    }
 
 	v := reflect.ValueOf(parentMap)
 	t := reflect.TypeOf(parentMap)
@@ -283,7 +288,7 @@
 		n = reflect.Zero(ft.Type)
 	}
 
-	if !isFieldTypeCompatible(ft, n) {
+	if !isFieldTypeCompatible(ft, n) && !IsValueTypeCompatible(ft.Type, v) {
 		return fmt.Errorf("cannot assign value %v (type %T) to struct field %s (type %v) in struct %T", fieldValue, fieldValue, fieldName, ft.Type, parentStruct)
 	}
 
@@ -452,14 +457,36 @@
 	return cmp.Equal(aa, bb)
 }
 
+func updateChildSchemaCache (schema *yang.Entry, tagStr reflect.StructTag, ygEntry *yang.Entry) {
+	schema.ChildSchemaMutex.Lock()		
+	schema.ChildSchemaCache[tagStr] = ygEntry
+	schema.ChildSchemaMutex.Unlock()
+}
+
 // ChildSchema returns the schema for the struct field f, if f contains a valid
 // path tag and the schema path is found in the schema tree. It returns an error
 // if the struct tag is invalid, or nil if tag is valid but the schema is not
 // found in the tree at the specified path.
 // TODO(wenbli): need unit test
 func ChildSchema(schema *yang.Entry, f reflect.StructField) (*yang.Entry, error) {
-	pathTag, _ := f.Tag.Lookup("path")
-	DbgSchema("childSchema for schema %s, field %s, tag %s\n", schema.Name, f.Name, pathTag)
+	schema.ChildSchemaMutex.Lock()
+	if (schema.ChildSchemaCache == nil) {
+		schema.ChildSchemaCache = make(map[reflect.StructTag]*yang.Entry)
+	}
+	schema.ChildSchemaMutex.Unlock()
+
+	schema.ChildSchemaMutex.RLock()
+	if cschema, ok := schema.ChildSchemaCache[f.Tag]; ok {
+		schema.ChildSchemaMutex.RUnlock()
+		return cschema, nil
+	}
+	schema.ChildSchemaMutex.RUnlock()
+	
+	if IsDebugSchemaEnabled() {
+		pathTag, _ := f.Tag.Lookup("path")
+		DbgSchema("childSchema for schema %s, field %s, tag %s\n", schema.Name, f.Name, pathTag)	
+	}
+	
 	p, err := RelativeSchemaPath(f)
 	if err != nil {
 		return nil, err
@@ -490,6 +517,7 @@
 	}
 	if foundSchema {
 		DbgSchema(" - found\n")
+		updateChildSchemaCache (schema, f.Tag, childSchema)
 		return childSchema, nil
 	}
 	DbgSchema(" - not found\n")
@@ -505,11 +533,15 @@
 		// path element i.e. choice1/case1/leaf1 path in the schema will have
 		// struct tag `path:"leaf1"`. This implies that only paths with length
 		// 1 are eligible for this matching.
+		updateChildSchemaCache (schema, f.Tag, nil)
 		return nil, nil
 	}
 	entries := FindFirstNonChoiceOrCase(schema)
 
-	DbgSchema("checking for %s against non choice/case entries: %v\n", p[0], stringMapKeys(entries))
+    if IsDebugSchemaEnabled() {
+		DbgSchema("checking for %s against non choice/case entries: %v\n", p[0], stringMapKeys(entries))
+    }
+    
 	for path, entry := range entries {
 		splitPath := SplitPath(path)
 		name := splitPath[len(splitPath)-1]
@@ -517,11 +549,13 @@
 
 		if StripModulePrefix(name) == p[0] {
 			DbgSchema(" - match\n")
+			updateChildSchemaCache (schema, f.Tag, entry)
 			return entry, nil
 		}
 	}
 
 	DbgSchema(" - no matches\n")
+	updateChildSchemaCache (schema, f.Tag, nil)	
 	return nil, nil
 }
 
diff -ruN ygot-dir-orig/ygot/ygen/codegen.go ygot-dir/ygot/ygen/codegen.go
--- ygot-dir-orig/ygot/ygen/codegen.go	2020-10-07 14:33:58.356199000 -0700
+++ ygot-dir/ygot/ygen/codegen.go	2020-10-27 16:02:47.723601000 -0700
@@ -15,6 +15,10 @@
 // Package ygen contains a library to generate Go structs from a YANG model.
 // The Goyang parsing library is used to parse YANG. The output can consider
 // OpenConfig-specific conventions such that the schema is compressed.
+
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ygen
 
 import (
@@ -946,7 +950,7 @@
 			dirs[ch.Path()] = ch
 			// Recurse down the tree.
 			errs = util.AppendErrs(errs, findMappableEntities(ch, dirs, enums, excludeModules, compressPaths, modules))
-		case ch.Kind == yang.AnyDataEntry:
+		case (ch.Kind == yang.AnyDataEntry), (ch.Kind == yang.NotificationEntry):	
 			continue
 		default:
 			errs = util.AppendErr(errs, fmt.Errorf("unknown type of entry %v in findMappableEntities for %s", e.Kind, e.Path()))
diff -ruN ygot-dir-orig/ygot/ygen/genstate.go ygot-dir/ygot/ygen/genstate.go
--- ygot-dir-orig/ygot/ygen/genstate.go	2020-10-07 14:33:58.365616000 -0700
+++ ygot-dir/ygot/ygen/genstate.go	2020-10-27 16:02:47.741918000 -0700
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ygen
 
 import (
@@ -83,6 +86,7 @@
 // noUnderscores boolean.
 func (s *enumGenState) enumeratedUnionEntry(e *yang.Entry, compressPaths, noUnderscores bool) ([]*yangEnum, error) {
 	var es []*yangEnum
+	enumSet := make(map[string]*yangEnum)
 
 	for _, t := range util.EnumeratedUnionTypes(e.Type.Type) {
 		var en *yangEnum
@@ -111,20 +115,36 @@
 				}
 			}
 
-			en = &yangEnum{
-				name: enumName,
-				entry: &yang.Entry{
-					Name: e.Name,
-					Type: &yang.YangType{
-						Name: e.Type.Name,
-						Kind: yang.Yenum,
-						Enum: t.Enum,
+			if tmpEn, ok := enumSet[enumName]; ok {
+				enumTmp := yang.NewEnumType()
+				for eNm, eVal := range t.Enum.NameMap() {
+					if err := enumTmp.Set(eNm, eVal); err != nil {
+						return nil, fmt.Errorf("%v", err)
+					}
+				}
+				for eNm, eVal := range tmpEn.entry.Type.Enum.NameMap() {
+					if err := enumTmp.Set(eNm, eVal); err != nil {
+						return nil, fmt.Errorf("%v", err)
+					}
+				}
+				tmpEn.entry.Type.Enum = enumTmp
+				continue
+			} else {
+				en = &yangEnum{
+					name: enumName,
+					entry: &yang.Entry{
+						Name: e.Name,
+						Type: &yang.YangType{
+							Name: e.Type.Name,
+							Kind: yang.Yenum,
+							Enum: t.Enum,
+						},
+						Annotation: map[string]interface{}{"valuePrefix": util.SchemaPathNoChoiceCase(e)},
 					},
-					Annotation: map[string]interface{}{"valuePrefix": util.SchemaPathNoChoiceCase(e)},
-				},
+				}
+				enumSet[enumName] = en
 			}
 		}
-
 		es = append(es, en)
 	}
 
diff -ruN ygot-dir-orig/ygot/ygot/render.go ygot-dir/ygot/ygot/render.go
--- ygot-dir-orig/ygot/ygot/render.go	2020-10-07 14:33:58.224638000 -0700
+++ ygot-dir/ygot/ygot/render.go	2020-10-27 16:02:47.544072000 -0700
@@ -45,6 +45,11 @@
 	p *gnmiPath
 }
 
+type structTagInfo struct {
+	gPathList []*gnmiPath
+	chModName string
+}
+
 func (p *path) String() string {
 	if p.p.isPathElemPath() {
 		return proto.MarshalTextString(&gnmipb.Path{Elem: p.p.pathElemPath})
@@ -870,19 +875,21 @@
 // the module name should be appended to entities that are defined in a different
 // module to their parent.
 func ConstructIETFJSON(s GoStruct, args *RFC7951JSONConfig) (map[string]interface{}, error) {
+	tagPaths := map[reflect.StructTag]*structTagInfo{}
 	return structJSON(s, "", jsonOutputConfig{
 		jType:         RFC7951,
 		rfc7951Config: args,
-	})
+	}, tagPaths)
 }
 
 // ConstructInternalJSON marshals a supplied GoStruct to a map, suitable for handing
-// to json.Marshal. It uses the loosely specified JSON format document in
+// to json.Marshal. It usstres the loosely specified JSON format document in
 // go/yang-internal-json.
 func ConstructInternalJSON(s GoStruct) (map[string]interface{}, error) {
+	tagPaths := map[reflect.StructTag]*structTagInfo{}
 	return structJSON(s, "", jsonOutputConfig{
 		jType: Internal,
-	})
+	}, tagPaths)
 }
 
 // jsonOutputConfig is used to determine how constructJSON should generate
@@ -902,7 +909,7 @@
 // be produced and whether such module names are appended is controlled through the
 // supplied jsonOutputConfig. Returns an error if the GoStruct cannot be rendered
 // to JSON.
-func structJSON(s GoStruct, parentMod string, args jsonOutputConfig) (map[string]interface{}, error) {
+func structJSON(s GoStruct, parentMod string, args jsonOutputConfig, tagPaths map[reflect.StructTag]*structTagInfo) (map[string]interface{}, error) {
 	var errs errlist.List
 
 	sval := reflect.ValueOf(s).Elem()
@@ -916,20 +923,51 @@
 		field := sval.Field(i)
 		fType := stype.Field(i)
 
+		switch field.Kind() {
+		case reflect.Map, reflect.Slice, reflect.Ptr, reflect.Interface:
+			if field.IsNil() {
+				continue
+			}
+		}
+
 		// Determine whether we should append a module name to the path in RFC7951
 		// output mode.
 		var appmod string
+
 		pmod := parentMod
-		if chMod, ok := fType.Tag.Lookup("module"); ok {
-			// If the child module isn't the same as the parent module,
-			// then appmod stores the name of the module to prefix to paths
-			// within this context.
-			if chMod != parentMod {
-				appmod = chMod
-			}
-			// Update the parent module name to be used for subsequent
-			// children.
-			pmod = chMod
+
+		var mapPaths []*gnmiPath
+		var err error
+
+		if tagInfo, ok := tagPaths[fType.Tag]; !ok {
+			tagInfoObj := new (structTagInfo)
+			tagInfoObj.gPathList, err = structTagToLibPaths(fType, newStringSliceGNMIPath([]string{}))
+			if err != nil {
+				errs.Add(fmt.Errorf("%s: %v", fType.Name, err))
+				continue
+			}
+			if chMod, modOk := fType.Tag.Lookup("module"); modOk {
+				// If the child module isn't the same as the parent module,
+				// then appmod stores the name of the module to prefix to pathsmakejson
+				// within this context.
+				if chMod != parentMod {
+					appmod = chMod
+				}
+				// Update the parent module name to be used for subsequent
+				// children.
+				pmod = chMod
+				tagInfoObj.chModName = chMod
+			} else {
+				tagInfoObj.chModName = pmod
+			}
+			tagPaths[fType.Tag] = tagInfoObj
+			mapPaths = tagInfoObj.gPathList
+		} else {
+			mapPaths = tagInfo.gPathList
+			pmod = tagInfo.chModName
+			if tagInfo.chModName != parentMod {
+				appmod = tagInfo.chModName
+			}
 		}
 
 		var appendModName bool
@@ -937,19 +975,8 @@
 			appendModName = true
 		}
 
-		mapPaths, err := structTagToLibPaths(fType, newStringSliceGNMIPath([]string{}))
-		if err != nil {
-			errs.Add(fmt.Errorf("%s: %v", fType.Name, err))
-			continue
-		}
-
 		var value interface{}
-
-		if util.IsYgotAnnotation(fType) {
-			value, err = jsonAnnotationSlice(field)
-		} else {
-			value, err = jsonValue(field, pmod, args)
-		}
+		value, err = jsonValue(field, pmod, args, tagPaths)
 
 		if err != nil {
 			errs.Add(err)
@@ -1086,7 +1113,7 @@
 // constructs the representation for JSON marshalling that corresponds to it.
 // The module within which the map is defined is specified by the parentMod
 // argument.
-func mapJSON(field reflect.Value, parentMod string, args jsonOutputConfig) (interface{}, error) {
+func mapJSON(field reflect.Value, parentMod string, args jsonOutputConfig, tagPaths map[reflect.StructTag]*structTagInfo) (interface{}, error) {
 	var errs errlist.List
 	mapKeyMap := map[string]reflect.Value{}
 	// Order of elements determines the order in which keys will be processed.
@@ -1155,6 +1182,7 @@
 	default:
 		return nil, fmt.Errorf("invalid JSON format specified: %v", args.jType)
 	}
+
 	for _, kn := range mapKeys {
 		k := mapKeyMap[kn]
 		goStruct, ok := field.MapIndex(k).Interface().(GoStruct)
@@ -1163,7 +1191,7 @@
 			continue
 		}
 
-		val, err := structJSON(goStruct, parentMod, args)
+		val, err := structJSON(goStruct, parentMod, args, tagPaths)
 		if err != nil {
 			errs.Add(err)
 			continue
@@ -1191,7 +1219,7 @@
 // The module within which the value is defined is specified by the parentMod string,
 // and the type of JSON to be rendered controlled by the value of the jsonOutputConfig
 // provided. Returns an error if one occurs during the mapping process.
-func jsonValue(field reflect.Value, parentMod string, args jsonOutputConfig) (interface{}, error) {
+func jsonValue(field reflect.Value, parentMod string, args jsonOutputConfig, tagPaths map[reflect.StructTag]*structTagInfo) (interface{}, error) {
 	var value interface{}
 	var errs errlist.List
 
@@ -1210,7 +1238,7 @@
 	switch field.Kind() {
 	case reflect.Map:
 		var err error
-		value, err = mapJSON(field, parentMod, args)
+		value, err = mapJSON(field, parentMod, args, tagPaths)
 		if err != nil {
 			errs.Add(err)
 		}
@@ -1223,7 +1251,7 @@
 			}
 
 			var err error
-			value, err = structJSON(goStruct, parentMod, args)
+			value, err = structJSON(goStruct, parentMod, args, tagPaths)
 			if err != nil {
 				errs.Add(err)
 			}
@@ -1235,7 +1263,7 @@
 		}
 	case reflect.Slice:
 		var err error
-		value, err = jsonSlice(field, parentMod, args)
+		value, err = jsonSlice(field, parentMod, args, tagPaths)
 		if err != nil {
 			return nil, err
 		}
@@ -1289,7 +1317,7 @@
 // GoStruct, a slice may be a binary field, leaf-list or an unkeyed list. The
 // parentMod is used to track the name of the parent module in the case that
 // module names should be appended.
-func jsonSlice(field reflect.Value, parentMod string, args jsonOutputConfig) (interface{}, error) {
+func jsonSlice(field reflect.Value, parentMod string, args jsonOutputConfig, tagPaths map[reflect.StructTag]*structTagInfo) (interface{}, error) {
 	if field.Type().Name() == BinaryTypeName {
 		// Handle the case that that we have a Binary ([]byte) value,
 		// which must be returned as a JSON string.
@@ -1305,7 +1333,7 @@
 			if !ok {
 				return nil, fmt.Errorf("invalid member of a slice, %s was not a valid GoStruct", c.Name())
 			}
-			j, err := structJSON(gs, parentMod, args)
+			j, err := structJSON(gs, parentMod, args, tagPaths)
 			if err != nil {
 				return nil, err
 			}
diff -ruN ygot-dir-orig/ygot/ygot/struct_validation_map.go ygot-dir/ygot/ygot/struct_validation_map.go
--- ygot-dir-orig/ygot/ygot/struct_validation_map.go	2020-10-07 14:33:58.231818000 -0700
+++ ygot-dir/ygot/ygot/struct_validation_map.go	2020-10-27 16:02:47.553165000 -0700
@@ -19,6 +19,10 @@
 //	  to return pointers to a type.
 //	- Renders structs to other output formats such as JSON, or gNMI
 //	  notifications.
+
+// This file is changed by Broadcom.
+// Modifications - Copyright 2019 Broadcom. The term Broadcom refers to Broadcom Inc. and/or its subsidiaries.
+
 package ygot
 
 import (
@@ -336,31 +340,12 @@
 // EmitJSON takes an input ValidatedGoStruct (produced by ygen with validation enabled)
 // and serialises it to a JSON string. By default, produces the Internal format JSON.
 func EmitJSON(s ValidatedGoStruct, opts *EmitJSONConfig) (string, error) {
-	var (
-		vopts          []ValidationOption
-		skipValidation bool
-	)
-
-	if opts != nil {
-		vopts = opts.ValidationOpts
-		skipValidation = opts.SkipValidation
-	}
-
-	if err := s.Validate(vopts...); !skipValidation && err != nil {
-		return "", fmt.Errorf("validation err: %v", err)
-	}
-
 	v, err := makeJSON(s, opts)
 	if err != nil {
 		return "", err
 	}
 
-	indent := indentString
-	if opts != nil && opts.Indent != "" {
-		indent = opts.Indent
-	}
-
-	j, err := json.MarshalIndent(v, "", indent)
+	j, err := json.Marshal(v)
 	if err != nil {
 		return "", fmt.Errorf("JSON marshalling error: %v", err)
 	}
@@ -525,7 +510,6 @@
 	for i := 0; i < srcVal.NumField(); i++ {
 		srcField := srcVal.Field(i)
 		dstField := dstVal.Field(i)
-
 		switch srcField.Kind() {
 		case reflect.Ptr:
 			if err := copyPtrField(dstField, srcField); err != nil {
@@ -555,7 +539,13 @@
 				dstField.Set(srcField)
 			}
 		default:
-			dstField.Set(srcField)
+                    if srcField.Type().Implements(reflect.TypeOf((*GoEnum)(nil)).Elem()) == true {
+                        if srcField.Int() != 0 {
+                            dstField.Set(srcField)
+                        }
+                    } else {
+                        dstField.Set(srcField)
+                    }
 		}
 	}
 	return nil
@@ -595,6 +585,7 @@
 			return err
 		}
 		dstField.Set(d)
+		
 		return nil
 	}
 
@@ -608,6 +599,7 @@
 	p := reflect.New(srcField.Type().Elem())
 	p.Elem().Set(srcField.Elem())
 	dstField.Set(p)
+	
 	return nil
 }
 
@@ -636,6 +628,7 @@
 		return err
 	}
 	dstField.Set(d)
+
 	return nil
 }
 
@@ -645,6 +638,7 @@
 // key is populated in srcField and dstField, their contents are merged if they
 // do not overlap, otherwise an error is returned.
 func copyMapField(dstField, srcField reflect.Value) error {
+
 	if !util.IsValueMap(srcField) {
 		return fmt.Errorf("received a non-map type in src map field: %v", srcField.Kind())
 	}
@@ -664,8 +658,6 @@
 	}
 
 	srcKeys := srcField.MapKeys()
-	dstKeys := dstField.MapKeys()
-
 	nm := reflect.MakeMapWithSize(reflect.MapOf(m.key, m.value), srcField.Len())
 
 	mapsToMap := []struct {
@@ -673,20 +665,24 @@
 		field reflect.Value
 	}{
 		{srcKeys, srcField},
-		{dstKeys, dstField},
 	}
 	existingKeys := map[interface{}]reflect.Value{}
 
+	for _, dstKey := range dstField.MapKeys()  {
+		existingKeys[dstKey.Interface()] = dstField.MapIndex(dstKey)
+	}
+	
 	for _, m := range mapsToMap {
 		for _, k := range m.keys {
 			// If the key already exists, then determine the existing item to merge
 			// into.
 			v := m.field.MapIndex(k)
 			var d reflect.Value
-			var ok bool
-			if d, ok = existingKeys[k.Interface()]; !ok {
+			if tmpVal, keyErr := compareMapKeys(existingKeys, k.Interface()); keyErr != nil {
 				d = reflect.New(v.Elem().Type())
 				existingKeys[k.Interface()] = v
+			} else {
+				d = *tmpVal
 			}
 
 			if err := copyStruct(d.Elem(), v.Elem()); err != nil {
@@ -804,3 +800,12 @@
 	}
 	return true, nil
 }
+
+func compareMapKeys(existingKeys map[interface{}]reflect.Value, searchKey interface{}) (*reflect.Value, error) {
+	for tmpKey, tmpVal := range existingKeys  {
+		if cmp.Equal(tmpKey, searchKey) {
+			return &tmpVal, nil
+		}		
+	}
+	return nil, fmt.Errorf("No match found in the existingKeys map.")
+}

